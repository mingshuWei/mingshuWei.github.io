---
layout:     post
title:      Android 安全机制
subtitle:   权限 签名 数据安全
date:       2017-11-01
author:     mingshu
catalog: true
tags:
    - 权限
    - 签名
    - 数据安全
---

# 权限
Android 权限分类：
1. 一类是高层的组件，例如应用和系统服务，这一部分一般采用包管理器依赖进行管理，查询。应用授予的权限写在packages.xml中
这里包括但不限于设备文件，UNIX套接字，网络套接字。Android进程主要通过UID，GID以及一组补充的GID实现的。众所周知，Android沙箱是以UID为基础实现的，每个进程拥有自己独特的UID(先不考虑共享UID)。进程的UID和GID会由包管理器映射到应用程序的UID。而补充gid则为额外的权限。值得一提的是，内置权限到组的映射是静态的。
```
static struct android_id_info android_ids[] = {
　　....
　　{ "shell", AID_SHELL, },
　　{ "cache", AID_CACHE, },
　　{ "net_bt_admin", AID_NET_BT_ADMIN, },
　　....
}

#define AID_NET_BT_ADMIN 3001 /* bluetooth: create any socket */
#define AID_NET_BT 3002       /* bluetooth: create sco, rfcomm or l2cap sockets */
#define AID_INET 3003         /* can create AF_INET and AF_INET6 sockets */
#define AID_NET_RAW 3004      /* can create raw INET sockets */
#define AID_NET_ADMIN 3005    /* can configure interfaces and routing tables. */
#define AID_NET_BW_STATS 3006 /* read bandwidth statistics */

<permission name="android.permission.BLUETOOTH_ADMIN" >
        <group gid="net_bt_admin" />
    </permission>
    <permission name="android.permission.BLUETOOTH" >
        <group gid="net_bt" />
    </permission>
    <permission name="android.permission.BLUETOOTH_STACK" >
        <group gid="bluetooth" />
        <group gid="wakelock" />
    </permission>
```
可得android.permission.BLUETOOTH_ADMIN映射的GID的3001。总而言之，包管理器在读取platfrom.xml时，并维护一个权限到GID的列表。在对一个安装中的包进行授权时，包管理器会检查每个权限是否有对应的GID。如果有，则加入在补充GID列表。当然，到这里只是确定了进程需要赋予哪些额外的gid。
并没有说怎么赋权的，这里要谈到一个叫zygote的进程，顾名思义，当Android启动新进程的时候，为了减少程序所需内存以及加快启动时间，Android会直接fork()zygote进程，并执行Android特有的函数进行分化而不执行固有的exec函数。简化代码如下
```
pid = fork();
 
if(pid ==0 ){
    err = setgroupsIntarray(gids);　　　　　　　　　　//设置补充gid
    err = setrlimitsFromArray(rlimits);　　　　　　　//设置资源限制
    err = setresgid(gid, gid, gid);　　　　　　　　　　//设置实际用户/组id
    err = setresuid(uid, uid, uid);　　　　　　　　　　//设置有效用户/组id
    err = setCapabilities(permittedCapabilities, effectiveCapabilities);　　　　　　//设置进程权能
    err = set_sched_policy(0, SP_DEFAULT);　　　　　　//设置调度策略
    err = setSELinuxContext(uid, isSystemServer, seInfo, niceName);　　　　　　//SElinux
}
```
2. 低层的组件，这一部分则是利用了传统了Linux DAC机制进行管理
从上面可以发现，这里包括了安装路径，版本号，签名证书，每个包的权限。上层的管理都是通过和包管理器和这个数据库进行交互的。由于组件不能在运行时改变权限，所以权限执行检查都是静态的。但它的执行一般分为两类，一类是静态，另一类是动态的。静态执行和动态执行流程大致相同：Binder.getCallingUid()和Binder.getCallingPid()获取调用者的UID和PID，然后利用UID映射包名，再获得相关权限。如果权限集合中含有所需权限即启动，否则抛出SecurityException异常。