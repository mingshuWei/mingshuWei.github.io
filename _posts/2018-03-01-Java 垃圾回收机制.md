---
layout:     post
title:      Java 垃圾回收
subtitle:   Java GC
date:       2018-03-01
author:     mingshu
catalog: true
tags:
    - Java
    - GC
---

# 垃圾回收简介
对于c、c++的开发人员来说内存是开发人员分配的，也就是说还要对内存进行维护和释放。于Java程序员来说，一个对象的内存分配是在虚拟机的自动内存分配机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码.
## Java 内存模型
主内存和工作内存：Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。ava内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。
内存间的交互操作：关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成。
lock unlock ，read load， use assign， store write 以及满足以下规则：
1. 不允许read和load、store和write操作之一单独出现
2. 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
3. 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
4. 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
5. 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现
6. 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
7. 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
8. 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

## Java 逻辑内存模型
Java 内存运行是数据区域分为以下几个部分

方法区：  也称"永久代” 、“非堆”，  它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB（未验证），可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。

运行时常量池，是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。

虚拟机栈：描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。
局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、 double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部 变量表的大小空间。

本地方法栈：与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。

堆：也叫做java 堆、GC堆，是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象)。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，-Xmx为JVM可申请的最大内存。在JVM启动时，最大内存会被保留下来。为对象内存而保留的地址空间可以被分成年轻代和老年代。

程序计数器：是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。

# 如何找打垃圾
可达性是指，如果一个对象会被至少一个在程序中的变量通过之间或间接的方法被其他可达的对象引用着，则称该对象为可达。一个对象满足以下两点之一即为可达：
1. 本身是根对象，根是指由堆以外空间访问的对象，jvm会将一个对象标记为根，包括全局变量，部分系统类，以及栈中引用的对象，如当前桢中的局部变量表和参数
2. 被一个可达的根引用。
有了这些概念可以看一下，标记-清除算法的具体过程。

# 垃圾回收机制
我们知道，随着程序的运行，各种对象的生命周期会有很大差别。实践表明，jvm中存在大量生命周期很短暂的对象，他们速生速死，而另外一些对象生命周期很长，甚至贯穿整个应用程序
及jvm的整个运行期。
因此在自动内存管理的设计上，对于不同的类型的对象，应采取不同的收集策略。基于此观点：将不同对象安排在不同区域，并在各区域执行有差别的收集算法。所以才有了如下分代的思想。

HotSpot虚拟机将其物理上划分为两个–新生代（young generation），老年代（old generation）和 持久代（ permanent generation ）。

新生代（Young generation）: 绝大多数最新被创建的对象会被分配到这里，由于大部分对象在创建后会很快变得不可到达，所以很多对象被创建在新生代，然后消失。对象从这个区域消失的过程我们称之为”minor GC“。
为了更好地理解GC，我们现在来学习新生代，新生代是用来保存那些第一次被创建的对象，他可以被分为三个空间

一个伊甸园空间（Eden ）
两个幸存者空间（Survivor ）
一共有三个空间，其中包含两个幸存者空间。每个空间的执行顺序如下：
绝大多数刚刚被创建的对象会存放在伊甸园空间。在伊甸园空间执行了第一次GC之后，存活的对象被移动到其中一个幸存者空间。此后，在伊甸园空间执行GC之后，存活的对象会被堆积在同一个幸存者空间。
当一个幸存者空间饱和，还在存活的对象会被移动到另一个幸存者空间。之后会清空已经饱和的那个幸存者空间。
在以上的步骤中重复几次依然存活的对象，就会被移动到老年代。JVM通过两个参数判断一个对象是否可以从新生代晋升到老年代：1. 年龄，即经历的minor gc 次数；2，对象大小。

老年代（Old generation）: 对象没有变得不可达，并且从新生代中存活下来，会被拷贝到这里。其所占用的空间要比新生代多。也正由于其相对较大的空间，发生在老年代上的GC要比新生代少得多。对象从老年代中消失的过程，我们称之为”major GC“（或者”full GC“）

持久代（ permanent generation ）也被称为方法区（method area）。他用来保存类常量以及字符串常量。因此，这个区域不是用来永久的存储那些从老年代存活下来的对象。这个区域也可能发生GC。并且发生在这个区域上的GC事件也会被算为major GC。

# 垃圾收集器
开始学习垃圾收集器前，了解以下基本知识
根据不同分代的特点，收集器可能不同。新生代收集器的收集频率高，应选择高性能的收集器；而老年代收集次数少，但对空间敏感，应当避免基于复制算法的收集器。
垃圾收集执行的时刻，应用程序需要暂停。
可以串行收集，也可以并行收集。
收集器的类型决定了堆的类型：

1. 串行收集器 Serial
应用程序暂定，收集器单线程开始收集
2. 并行收集器 ParNew
采用多个gc 线程并行工作。

# 堆的类型
不同的收集器，选用的内存管理方式有所区别。这点反应在堆的内存区域划分上有所区别，这意味着不同的收集器对应着不同类型的堆。
HotSpot提供一些vm选项，可以选择堆的类型。事实上，这些由配置的收集器决定。系统按照一定的顺序选择堆类型。

# 垃圾收集算法
1. 标记-清除
标记阶段：标记可回收的对象
清除阶段：回收已标记对象，释放该部分空间
2. 复制算法
划分区域：一个Eden 两个suvivor
复制：收集时从一个eden  复制到一个survivor
清除：清除被复制的
晋升：survivor装不下的晋升到老年代
3. 标记-压缩
标记阶段：标记可回收
压缩阶段：标记的对象移动到另一端，释放空间。

一般来说，复制算法简单直观，以牺牲空间换取运行时高效，比较适合新生代。对于老年代说，该代的对象生命周期一般较长，如果用复制算法，导致较多的复制，降低收集效率，反而基于
标记的算法更适合老年代。

# 实战： 性能分析方法

> https://www.cnblogs.com/wozixiaoyao/p/5658950.html

> HotSpot 实战

> 深入理解虚拟机 周志明

